# React

 - 리액트는 SPA를 만드는 라이브러리이다.
 - SPA는 페이지 이동없이 동적인 콘텐츠를 표시할 수 있는 어플리케이션이며, SPA를 구현하기 위해서는 여러 콘텐츠를 사용자와의 상호작용에 따라 보여줘야 한다.


## React의 특징

1. 선언형 접근법과 JSX

- 리액트는 선언형 접근법(Declarative approach)을 사용하는데, 이는 만들어지는 최종 상태만을 정의하고 그러한 상태가 만들어지는 방법 혹은 규칙에 대한 정의는 하지 않는 것을 의미한다.
-  여기서 말하는 최종 상태란, 한 가지 상태만을 의미하지 않고 다양한 조건에 따른 여러 상태를 의미한다.
- 상태를 변경시키는 규칙을 정하는 명령형 프로그래밍(Imperative programming)과는 반대되는 개념이다.
- 기존의 자바스크립트는 화면에 요소를 그리기 위해서는 그 요소가 그려지는 방법을 코드로 정의하여야 했습니다.
-  createElement(), getElementById(), append()등의 방법으로 새로운 내용이 그려지는 과정을 하나하나 컨트롤 해줘야 한다.
- 하지만 리액트는 JSX를 도입하여 자바스크립트코드로 HTML과 거의 같은 문법을 사용할 수 있게 함으로, 요소가 그려진 결과를 보여주기만 하면 리액트가 자동으로 처리하여 화면에 요소를 그리게 된다.


기존 코드

```
const content = document.createElement('p');
content.textContent = '새로운 내용';
document.getElementById('content-box').append(content)
```

리액트 JSX 사용

```
function App() {
  return (
    <div>
      <p>새로운 내용<p>
    </div>
  );
}

export default App;
```

- 위의 코드처럼 완성된 HTML의 모습을 보여주면, 리액트가 그 모양과 똑같이 자동으로 페이지를 그려주도록 하는 것이 JSX의 사용방식이다. 
- 이를 통해 DOM을 조작하는 복잡한 코드가 필요없어진다.

## 왜 가상 돔을 사용할까

- 바닐라 자바스크립트를 사용했을 때, 브라우저의 DOM Selector API를 사용해서 특정 DOM을 선택하고 변화를 주려면 조건에 따른 수많은 규칙을 만들어야 한다.
- 이러한 규칙은 페이지의 요소가 많아질수록 급속도로 복잡해져서 관리가 어려워진다.
- 그래서 DOM의 업데이트를 간소화할 방법이 필요했습니다. 
- 여기서 리액트는 새로운 발상을 하였는데, DOM이 바뀌면 어떻게 업데이트되는지에 대한 규칙을 만드는(명령형 프로그래밍) 대신 이전의 DOM을 없애고 새로 만들어진 결과로 바꿔서 보여줍니다(선언형 프로그래밍).
-  이 덕에 업데이트를 하는 방법에 대해서는 고민할 필요가 없어진며 이는 곧 코드가 간단해짐을 뜻한다.

- 하지만 매번 모든 DOM을 새롭게 만든다면 페이지의 전환마다 새로운 페이지가 생성되므로 속도가 느려진다.
-  그래서 리액트는 가상 DOM이라는 것을 만들었습니다. 가상 DOM은 이름처럼 실제 DOM이 아니라 자바스크립트의 객체로써 존재한다.
- 그래서 가상 DOM을 조작하거나 만드는 것은 실제로 렌더링이 되지 않는 등의 측면에서 실제 DOM을 조작하고 만드는 것보다 훨씬 빠르다.
- 리액트는 상태가 업데이트되면 먼저 가상 DOM을 만들고 실제 DOM과 다른 부분을 찾아 해당하는 부분만을 다시 그린다.
- 이때, 다른 부분을 한 번에 다시 그린다. 리액트는 필요한 부분만 한 번에 다시 그리는 방식을 통해 빠른 속도를 보장하였고, 동시에 개발자가 실제 DOM에 접근할 필요가 없게 만들어주어 관리를 더 쉽게 만들어준다.
- 요약하자면, 리액트가 가상 DOM을 사용하는 이유는 DOM의 빠른 업데이트 뿐만 아니라, 선언형 접근법을 유지하기 위해서이다.


## 상태와 리렌더링

- 리액트의 컴포넌트는 상태가 변하면 해당 컴포넌트를 재평가(함수형 컴포넌트라면 함수를 재실행, 클래스형 컴포넌트라면 다시 인스턴스화)하여 새로운 내용이 반영하여 새로 UI를 그린다.
- 이러한 행위를 리렌더링(re-rendering)이라고 한다.
- 결국 리액트는 최초 렌더링 - 상태의 변화 - 리렌더링(렌더링)의 단계를 거치며 새로운 컨텐츠를 화면에 표시하는 것이다.



- 먼저 리액트의 컴포넌트가 최초로 렌더링된다.
- 그리고 상태변화 요청이 오기 전까지는 계속 대기한다.
- 그러다가 사용자가 버튼을 누르는 등의 행동을 통해 상태를 변화(set함수를 호출하는 로직을 실행)시키면 리액트는 해당 요청을 받아 새로운 값으로 상태를 변경한다.
- 컴포넌트의 최초 변경과 상태(state)변화를 일으키는 행위를 트리거(Trigger)라고 부른다.
- 이 과정 중에 컴포넌트는 재평가가 됩니다(아직 다시 렌더링이 되지는 않았다.)
-  컴포넌트가 재평가되면 변화된 내용은 먼저 가상 DOM에 반영되며, 리액트에서는 이 과정을 렌더링(Rendering)이라고 한다.
 
- 그러고나면 리액트는 가상 DOM과 실제 DOM의 내용을 비교한다.
- 만약 두 내용이 다르다면 가상 DOM의 내용 중 실제 DOM과 다른 부분을 모두 긁어 모아 실제 DOM으로 내용을 한번에  덮어쓰게된다.
- 만약 실제 DOM에 있던 내용이 가상 DOM에는 없으면 그 내용은 삭제하게 되는 식이죠. 그러면 사용자는 리액트에 의해 변화된 콘텐츠를 볼 수 있게 된다.
- 이 과정을 커밋(Commit)이라고 하며 이때, 컴포넌트 재평가 후 가상 DOM과 실제 DOM의 내용이 같다면 리액트는 아무런 행동도 하지 않는다.


## React Hook
 - 리액트는 훅이라고 불리는 것으로 동적인 값을 관리할 수 있다.
 - '훅'이라는 용어는 함수형 컴포넌트 내에서 특정한 리액트 기능에 "연결(hook into)"하거나 액세스할 수 있는 개념을 나타낸다.

## Hook 규칙
- 리액트의 모든 Hook들은 **컴포넌트의 최상위 수준** 혹은 **커스텀 훅**에서만 호출할 수 있다.
- 따라서 조건문 또는 반복문의 내부 혹은 중첩된 함수 내부에서 사용이 불가능하다.
- 그 이유는 리액트의 Hook은 각 Hook이 호출되는 순서에 의존하기 때문에 호출되는 순서가 달라지면 문제가 발생하기 때문. 예를 들어 A, B, C, D라는 훅이 순서대로 호출되었다고 가정한다. 만약 리렌더링 단계에서 B, A, C, D 순서로 호출된다면, B는 이전 A의 값을 A는 이전 B의 값을 읽어 버리게 되어 버그가 발생한다.


## 1. useState

```
import { useState } from 'react';

const SomeComponent = () => {
    const [someValue, setSomeValue] = useState(0)
}
```

- 이 hook의 인자는 상태의 초기값이며 문자, 숫자, 객체... 어느것으로든 만들 수 있다.
- useState는 두개의 요소가 들어있는 배열을 반환하는 데, 첫 번째 요소는 상태의 값을 나타내고 두 번째 요소는 함수로 상태를 변화시키는 함수이다.

### set 함수의 규칙

1.  상태의 값을 직접 변경해서는 안된다.
- useState의 반환값의 첫 번째 요소는 상태의 값이다. 
- 만약 이 값을 직접 변경하는 경우엔  먼저 리액트가 변경을 감지하지 못하여 리렌더링이 일어나지 않습니다.
- 대신 useState의 두 번째 반환값인 함수를 사용하여 상태를 업데이트하여야 한다.
- 이 함수는 리액트가 상태 변경을 감지하여 리렌더링을 할 수 있도록 만들어줍니다.
- 만약 상태의 값을 직접 변경하면 리액트는 해당 변경을 감지하지 못하여 리렌더링이 일어나지 않아 새로운 상태를 사용자가 확인할 수 없다.
 
2. state는 읽기 전용이다.
- state는 읽기 전용으로 애초에 수정하기 위해 만들어진 값이 아니다.
- 따라서 상태의 값이 객체인 경우라도 직접 수정해서는 안되며, 대신 자바스크립트의 스프레드 문법을 사용하여 새로운 객체를 생성한 뒤 set함수를 사용해서 수정해야 한다.


```
import { useState } from 'react';

const SomeComponent = () => {
    const [someValue, setSomeValue] = useState(0)


const Example1 = () => {
setSomeValue(someValue + 1);
setSomeValue(someValue + 1);
setSomeValue(someValue + 1);

console.log(someValue) ## 1

}

const Example2 = () => {
    setSomeValue((prevValue) => prevValue + 1)
    setSomeValue((prevValue) => prevValue + 1)
    setSomeValue((prevValue) => prevValue + 1)

}
console.log(someValue) ## 3

}

```



## 2. useEffect


useEffect는 컴포넌트의 생명주기와 비슷한데요. 하지만 react 공식 문서에서는 이와는 분명히 다르다고 언급하고 있습니다. 컴포넌트의 마운트/언마운트 등과는 실행 시점이 다를 수 있기 때문입니다. 정확하게는 생명주기보다는 우리가 지정한 props와 state에 따라 DOM과 동기화하는 시점이라고 보시면됩니다. 혹은 화면에 렌더링이 반영될 때까지 코드 실행을 '지연'시킨다고 생각하셔도 좋습니다.
 
- 실제 useEffect를 사용하는 상황은 컴포넌트의 부수효과(side effect)를 관리하기 위해서이다.
- 이벤트 핸들러가 아닌 렌더링과 관련되어서(정확하게는 렌더링 이후) 실행되어야 하는 effect들이 있습니다.

- Ex) 
실시간 웹 소켓에 연결하여 실시간 채팅을 처리하는 경우가 그런데, 이러한 연결은 컴포넌트의 표시를 제어하는 상호 작용과 독립적으로 발생해야 합니다. useEffect를 사용한다면, 해당 함수는 렌더링 이후 실행되므로 컴포넌트 업데이트가 완료된 후 (백엔드 서버의 데이터를 받아오는 등)외부 시스템과 동기화 작업을 수행할 수 있습니다. 


### 비어있는 의존성 배열을 받은 useEffect
먼저 컴포넌트의 생명주기와 동일한 시점에 실행되는 useEffect를 알아보자.
```
const SomeComponent = () => {
    useEffect(()=> {
        // 컴포넌트가 마운트 되었을 때 실행할 코드 : effect logic
        return () => {
            // 컴포넌트가 언마운트 되기 직전에 실행할 코드 : clean up logic or clean up function
        }
    }, []);
}
```

- useEffect는 두 개의 인자를 받는다. 
- 첫번째 인자에는 함수, 두 번째 인자에는 배열이 들어가게 됩니다.
- 여기에 들어가는 함수는 useEffect가 실행하는 코드입니다.
- useEffect가 실행되는 시점은 두 번째 인자인 배열에 달렸다.
- 이 배열을 의존성 배열이라고 하는데, 현재는 빈 배열이 들어간 코드이다.

* 의존성 배열useEffect를 비롯한 몇몇 Hook들은 의존성 배열을 인자로 받는다.
* 의존성 배열이라는 이름처럼 이 배열에는 해당 Hook이 의존하고 있는 값들이 들어가야 한다.
* 기본적으로 이 의존성 배열 요소 값들이 바뀌면 Hook이 실행된다고 생각하면 된다.
* useEffect의 경우는 이 의존성 배열 내부의 값들이 변화하면 자신이 받은 함수를 실행하게 된다.

의존성 배열이 비어있기 때문에 해당 코드의 useEffect는 컴포넌트의 변화가 얼마나 많던지 상관하지 않습니다. 그래서 useEffect는 컴포넌트가 처음 마운트되었을 때 자신이 첫 번째 인자로 받은 함수인 effect 로직을 실행합니다. 그리고 이 함수가 반환하는 함수인 clean up 함수는 잘 가지고 있다가 컴포넌트가 언마운트될 때(현재 코드에선 이 단계가 리렌더링 직전 시점입니다.) 실행되도록 합니다.


### 의존성 배열을 받은 useEffect

그렇다면 의존성 배열에 요소가 있다면 어떻게 동작할까?
```
const SomeComponent = () => {
    const [count, setCount] = useState(0)

    useEffect(()=> {
        // 첫 번째 렌더링 혹은 count가 변경되었을 때 되었을 때 실행할 코드
        return // count의 변경으로 다음 effect function이 호출되기 전 혹은 컴포넌트 언마운트 전에 실행할 코드
    }, [count]);
}
```

- 위의 코드에서 만약 count의 값이 변경된다면 그 즉시 useEffect의 effect 로직이 실행된다.
-  그리고 상태가 변경되었으니 컴포넌트를 재평가하게 되며, 리렌더링 직전에 clean up 함수가 실행됩니다.
- 하지만 리액트의 리렌더링 방법에 따라, 컴포넌트 재평가 전과 후의 값이 같다면 clean up 함수는 실행되지 않는다.
-  clean up 함수는 재평가 이후 값이 달라져, 리렌더링이 일어 나야하면 리렌더링 직전에 수행되는 것이다.

### 의존성 배열을 받지 않은 useEffect
- 그런데 의존성 배열을 파라미터로 가지는 Hook들은 이 의존성 배열을 생략할 수 있다.
- 그렇게 되면 컴포넌트의 모든 렌더링마다 해당 Hook이 실행된다.

```
const SomeComponent = () => {
    useEffect(()=> {
        // 매 렌더링마다 실행할 코드
        return // count의 변경으로 다음 effect function이 호출되기 전과 언마운트 직전에 실행할 코드
    });
}
```
- 위의 코드는 SomeComponent가 렌더링 될 때마다 실행되는 코드와 매 렌더링 직전(그리고 언마운트 직전)마다 실행할 코드를 작성할 수 있다.

