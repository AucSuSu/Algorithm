# 트랜잭션 격리 수준

## 트랜잭션 격리 수준(Transaction Isolation Level)이란?
- 데이터베이스에서 여러 트랜잭션이 동시에 실행될 때, 한 트랜잭션이 다른 트랜잭션에서 처리 중인 데이터에 접근하거나 영향을 주는 것을 어느정도 허용할지 결정하는 설정!


![image](https://github.com/AucSuSu/CS-study/assets/109134365/787ee844-8bd5-4966-a56f-6d4d70b1b3d0)

>사용자 1,2가 동일한 계좌에 100원씩 동시에 송금하는 상황.
이때 트랜잭션 격리 수준이 존재하지 않으면 어떻게 될까?


사용자 1,2의 송금 **트랜잭션이 동시에 실행**되면 두 명이 100원씩 송금 했음에도 불구하고 계좌 잔고는 1000원에서 100원만 증가된 1100원 이 된다.

정상적으로 결과가 나오려면
![image](https://github.com/AucSuSu/CS-study/assets/109134365/d849c64f-4425-4e9d-8c4c-06f0568f9e4c)

사용자 1의 트랜잭션이 끝나고, 사용자 2의 트랜잭션이 발생해서 총 200원 증가한 1200원이 반영이 되어야 한다.

위처럼 여러 트랜잭션이 같은 데이터를 동시에 읽고 쓸 때에는 수많은 **동시성 문제**가 발생!

트랜잭션 격리 수준은 이러한 동시성 문제를 해결하기 위해 도입.

**여러 트랜잭션이 동시에 실행됐더라도 그 결과가 트랜잭션이 순차적으로 실행됐을때의 결과와 동일함을 보장**

이제 트랜잭션 격리 수준들을 알아보자.


## 커밋되지 않은 읽기(Read Uncommitted)

커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하는 격리 수준.
다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보임.

Dirty Read가 매우 발생

![image](https://github.com/AucSuSu/CS-study/assets/109134365/af412e9a-2a39-4649-bb27-9f5d5fd94f95)

아까 봤던 사진이 해당함.


## 커밋 후 읽기(Read Committed) 격리 수준
가장 기본적인 격리 수준. 가장 많이 사용되는 격리 수준

2가지를 보장!

>1. DB에서 읽을 때 커밋된 데이터만 읽는다 (Dirty read가 없음을 보장)
>2. DB에 쓸 때 커밋된 데이터만 덮어쓴다 (Dirth write가 없음)

이게 무슨 말이냐?

**Dirty read**는 커밋되지 않은 데이터를 read 하는 것을 말하는데, 이것을 하지 않는다 ==> 커밋된 데이터만 읽자.

**Dirty write**는 커밋되지 않은 데이터를 write 하는 것을 말하는데, 이것을 하지 않는다 ==> 커밋된 데이터만 덮어쓴다.

![image](https://github.com/AucSuSu/CS-study/assets/109134365/18ccca8e-af2b-4643-a582-46c3a6836ea8)

위의 사진처럼 커밋된 데이터만 읽는 것이 Dirty read 방지이다.

그럼 **Dirty read**는 왜 막음???

![image](https://github.com/AucSuSu/CS-study/assets/109134365/6ba9c8d2-7eb8-4a99-a093-cc23e5539aab)


1. 사용자 1의 트랜잭션에서 메세지 A가 도착했을때, 안읽은 메세지 A를 추가하고, 안읽은 메세지 카운트를 1증가 한다.
2. 근데 사용자 2가 사용자 1의 안읽은 메세지 카운트 1 증가 전에 READ를 하게되면 안읽은 메세지 수는 0개로 표시된다 ---> 이게 **Dirty Read**


그래서 이걸 막으려고 커밋 후 읽기 격리 수준을 사용.




그럼 **Dirty write**는 왜 막음????



![image](https://github.com/AucSuSu/CS-study/assets/109134365/09774ff1-3e38-46b9-8e06-748f1cb6db8c)

1. 사용자 1인 Alice가 물건 A를 구매 해서 구매자가 Alice로 바뀜.
2. 사용자 2인 Bob이 Alice의 트랜잭션 진행중에 물건 A를 구매해서 구매자, 이메일 수신자를 모두 Bob으로 바꿈
3. 사용자 1인 Alice가 이메일 수신자로 변경됨.


이걸 막으려면 이렇게 해야됨.

![image](https://github.com/AucSuSu/CS-study/assets/109134365/36588d98-2083-443a-a493-65db7a6a0f16)


**커밋되지 않은 값을 발견하면 기다림!**


### 커밋 후 읽기(Read Committed)는 만능일까?

정답은 ㄴㄴㄴㄴ   아래의 예시를 보자

![image](https://github.com/AucSuSu/CS-study/assets/109134365/d2e8f847-ec9e-42d4-908e-feaa4ceeabde)


1. 사용자 2가 계좌 1의 값을 읽음. -> 계좌 1 : 1000원
2. 사용자 1이 계좌 1에서 2로 500원 송금 -> 계좌 1: 500원, 계좌 2: 1500원
3. 사용자 2가 계좌 2의 값을 읽음 -> 계좌 2 : 1500원

계좌 1 : 1000원 + 계좌 2 : 1500원 ========> 500원이 갑자기 생김 ㄱㅇㄷ

이러면 안됨. 2000원 유지 되어야함.

근데 이러한 경우는 사용자 2가 새로고침을 하면 괜찮으니까 지속적인 문제는 아님.
하지만 특정 상황에서는 이런 일시적인 비정상 응답의 반환조차 허용하면 안되는 경우가 있음.

- 데이터베이스 백업 : 데이터 베이스 백업엔 많은 시간이 걸리는데 도중에 write가 실행되면 이전 버전 데이터와 새로운 버전 데이터가 다르므로 일관성이 깨짐.
- 시간이 오래 걸리는 쿼리 : 쇼핑몰에서 매일 24:00에 상품의 재고와 판매량에 대한 무결성 검사를 실행(시간이 오래 걸리는 쿼리)하게 된다. 이게 진행될때,
  다른 트랜잭션에 의해 상품의 판매기록이 업데이트되고 커밋되어야 하는데 최신 기록이 반영이 안될거임.


이것을 해결하는게 반복 읽기(Repeatable Read) 격리 수준!

## 반복 읽기 격리 수준(Repeatable Read)
> 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준


"스냅숏 격리"를 사용하는 반복 읽기

![image](https://github.com/AucSuSu/CS-study/assets/109134365/652fbb6c-2186-4562-8f46-62e70b425cf0)

**스냅숏 격리**란 데이터 베이스가 각 데이터 마다 여러 버전의 값들을 유지하고, 각 트랜잭션 마다 순서인 txid(트랜잭션 id)
를 부여하여 트랜잭션 별로 읽을 수 있는 데이터를 특정 시점의 데이터로 고정(스냅숏을 찍어서)하여 이후의 트랜잭션들에서 가해진 변경으로 부터 데이터를 보호.


그래서 사용자 2는 사용자 1이 계좌 업데이트 했음에도 **이전 버전의 데이터들을 일관성있게 바라볼 수 있다**

다중 버전 동시 제어(multi version concurrency control, **MVCC**) 라고도 불린다.

반복 읽기 격리 수준은 새로운 레코드의 추가까지는 막지 않는다.

그래서 SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데 이를 **유령 읽기(Phantom Read)** 라고 한다.


## 직렬성(Serializable)

![image](https://github.com/AucSuSu/CS-study/assets/109134365/f78ebd5e-1fea-4f57-8fb6-ea7c47fe868c)

가장 엄격한 격리 수준으로, **트랜잭션을 순차적으로 진행**시킨다.
여러 트랜잭션이 동일한 레코드에 동시 접근 못함. 데이터 부정합 문제 발생도 안함.
트랜잭션이 순차적으로 처리 -> 동시 처리 성능 매우 안좋겠죠?

순수한 Select 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락, Shared Lock) 으로 건다.

따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다.

Serializable은 가장 안전하지만 가장 성능이 떨어지므로 극단적인 경우 아니면 사용하지 말자.


## 참고 자료
https://medium.com/@10x.developer.kr/db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-%EA%B7%B8%EB%A6%BC%EA%B3%BC-%EC%98%88%EC%8B%9C%EB%A1%9C-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1%ED%8E%B8-5bef68de8b7b
