## JWT(Json Web Token)
> 정보를 비밀리에 전달하거나 인증할 때 주로 사용하는 토큰으로, Json객체를 이용함

- 일반적으로 클라이언트와 서버 사이에서 통신할 때 권한을 위해 사용하는 토큰.
- 웹 상에서 정보를 Json형태로 주고 받기 위해 표준규약에 따라 생성한 암호화된 토큰
  - 복잡하고 읽을 수 없는 string 형태로 저장
 
## JWT의 구성요소
> Json 형태인 각 부분은 Base64Url로 인코딩 ➡️ 암호화된 문자열은 아님!
> '.' 구분자를 사용하여 구분
- 헤더(Header)
- 페이로드(Payload)
- 서명(Signature)
![image](https://github.com/AucSuSu/CS-study/assets/64372881/f7574654-9cf3-4d4c-bd8c-c435177fdbae)
![image](https://github.com/AucSuSu/CS-study/assets/64372881/0a373a0e-460f-475a-9f6d-66dad35d4a7f)

### 헤더(Header)
- 어떤 알고리즘으로 암호화 할지
- 어떤 토큰을 사용할지에 대한 정보

### 페이로드(Payload)
- 전달하려는 정보(사용자 id나 다른 데이터) 보유 ➡️ 이를 클레임(claim)이라고도 함
- payload에 있는 내용은 수정이 가능하여 더 많은 정보를 추가 가능
- 그러나 노출과 수정이 가능한 지점이기 때문에 인증이 필요한 최소한의 정보만을 담아야함
  - 아이디, 비밀번호 등 개인정보가 아닌!!
  - 이 토큰을 가졌을 때 권한의 범위나 토큰의 발급일과 만료일자 등
- 3가지 종류
  - 등록된 클레임(Registered Claim): 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터
    - iss: 토큰 발급자(issuer)
    - sub: 토큰 제목(subject)
    - aud: 토큰 대상자(audience)
    - exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370
    - nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음
    - iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음
    - jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용
  - 공개 클레임(Public Claim): 사용자 정의 클레임으로, 공개용 정보를 위해 사용
    - ```
      { 
        "https://mangkyu.tistory.com": true
      }
  - 비공개 클레임(Private Claim): 사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장
    - ```
      {
        "token_type": access 
      }
### 서명(Signature)
- 헤더와 페이로드를 합친 후 발급해준 서버가 지정한 secret key로 암호화 ➡️ 토큰 변조에 어려움, 보안!
- 예시
  - 토큰이 발급된 후 누군가가 Payload의 정보를 수정.
  - Payload에는 다른 누군가가 조작된 정보가 들어가 있지만 Signatute에는 수정되기 전의 Payload 내용을 기반으로 이미 암호화 되어있는 결과가 저장
  - 조작되어있는 Payload와는 다른 결과값 도출
  - 이러한 방식으로 비교하면 서버는 토큰 조작을 쉽게 알아차림. 보안에 큰 도움!

## JWT의 동작원리
![image](https://github.com/AucSuSu/CS-study/assets/64372881/141b5d2f-9f32-4367-b6a9-22487201d199)
1. 사용자가 id와 password를 입력해 로그인 요청
2. 서버는 회원 DB에 들어있는 사용자인지 확인
3. 서버는 로그인 요청 확인 후, secret key를 통해 토큰을 발급
4. 이것을 클라이언트에 전달
5. 서비스 요청과 권한을 확인하기 위해 헤더에 데이터(JWT) 요청
6. 데이터를 확인 후, JWT에서 사용자 정보를 확인
7. 클라이언트 요청에 대한 응답과 요청한 데이터를 전달

➡️ 토큰 기반 인증방식은 사용자의 인증이 완료된 이후에 토큰을 발급.<br> 
➡️ 클라이언트는 전달받은 토큰을 저장, 서버에 요청을 할 때마다 해당 토큰을 서버에 함께 전달.<br>
➡️ 그 이후 서버는 토큰을 검증하고 응답하는 방식으로 작동.<br>

![image](https://github.com/AucSuSu/CS-study/assets/64372881/72e00ccc-2d56-4e89-b9a0-75d7f028d8f6)
- 애플리케이션이 실행될 때, JWT를 static 변수와 로컬 스토리지에 저장.
- static 변수에 저장되는 이유:
  - HTTP 통신을 할 때마다 JWT를 HTTP 헤더에 담아서 보내야 함.
  - 이를 로컬 스토리지에서 계속 불러오면 오버헤드가 발생.
- 클라이언트에서 JWT를 포함해 요청을 보내면 서버는 허가된 JWT인지를 검사.
- 로그아웃을 할 경우 로컬 스토리지에 저장된 JWT 데이터를 제거한다.


## 일반 토큰 기반 vs 클레임 토큰 기반
> JWT를 사용하는 가장 큰 이유는 클레임(Claim) 토큰 기반 인증이 주는 편리함.
### 일반 토큰 기반 인증 
- 토큰을 검증할 때 필요한 관련 정보들을 서버에 저장 ➡️ 항상 DB에 접근해야 함.
- session방식 또한 저장소에 저장한 session ID를 찾아와 검증하는 절차를 가져 다소 번거로움
### 클레임 토큰 기반 인증 JWT
- 사용자 인증에 필요한 모든 정보를 토큰 자체에 담고 있음 ➡️ 별도의 인증 저장소가 필요 없음.
  - 이를 Self-Contained 방식이라고 한다. 
- 분산 마이크로 서비스 환경에서 중앙 집중식 인증 서버와 데이터베이스에 의존하지 않는 쉬운 인증을 제공 ➡️ 일반 토큰 기반 인증에 비해 편리.


## Reference
- https://velog.io/@hahan/JWT%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80
- https://mangkyu.tistory.com/56
