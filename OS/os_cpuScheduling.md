## 스케줄러

컴퓨터가 가진 자원은 한정적이다.

CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 **모든 상태 변화를 조정**하는 일을 한다.

스케줄러가 하는 CPU 스케줄링은 어떤 프로세스에 CPU를 배정할지 결정한다.

<br/>

## 스케줄러의 목적

**공평성** : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.

**효율성** : 시스템 자원을 놀리는 시간 없이 스케줄링해야 한다.

**안정성** : 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.

**반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.

**무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

<br/>

## 스케줄링 단계

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F993FEE355BB5F49021)

> ### **장기 스케줄러**

장기 스케줄러는 프로세스의 생성 과정에서 프로세스의 준비 상태에 무엇을 추가할지 결정하고 메모리의 사용 가능 공간 및 자원을 확인한다.

즉, 장기 스케줄러는 **다중 프로그램의 정도(= 메모리에 있는 프로세스들의 수)를 제어**한다.

<br/>

> ### **중기 스케줄러**

중기 스케줄러는 스왑 기능의 일부로 메모리에 부분적으로 프로세스를 적재하고 일시중지된 프로세서의 원인을 해결하면 다시 준비 상태로 만든다.

가상 메모리 체제에서는 너무 많은 프로세스가 메모리에 적재되면 하드 디스크 입출력이 과다해져 시스템이 거의 멈추는 현상이 발생한다. => ### **Thrashing** 이를 예방하기 위해 **Swapping**

<br/>

> ### **단기 스케줄러**

단기 스케줄러는 미리 정한 **스케줄링 알고리즘**에 따라 실행할 프로세스를 선택한다.

프로세스 실행상태에서 대기 혹은 준비 상태로 변화시키는 역할을 한다.

<br/>

## 비선점 / 선점 스케줄링

> ### **비선점 스케줄링 (Non-preemptive Scheduling)**

프로세스가 종료하거나 대기 상태로 전환해 **CPU를 자진 반납할 때까지 CPU에 의한 실행을 보장해주는 스케줄링**

작업 실행 시간 전체 또는 한 번의 CPU 배당에 대해 적용된다.

- 선입 선처리 스케줄링 (FCFS)
- 최단 작업 우선 스케줄링 (SJF) _- 선점형으로도 가능_
- 우선순위 스케줄링 _- 선점형으로도 가능_

 <br/>

> ### **선점 스케줄링 (Preemptive Scheduling)**

(1) 시분할 시스템에서 **타임 슬라이스가 소진되었거나,**

(2) 인터럽트 또는 시스템 호출 종료 시 그 여파로 현재 실행 중인 프로세스보다 **높은 우선순위의 프로세스가 나타나는 경우**

현 프로세스로부터 **CPU를 강제로 회수하여 높은 우선순위의 프로세스를 실행하는 스케줄링**

- 라운드 로빈 스케줄링 (RR)
- 다단계 큐 스케줄링
- 다단계 피드백 큐 스케줄링

<br/>

## 스케줄링 알고리즘

- ### 비선점형 방식

> ### **FCFS (First Come, First Served)**

<span style="color: red"> ###**기준: 도착순서**</span> ###

가장 간단한 CPU 스케줄링 알고리즘

CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는 **선입 선출**의 방식

<br/>

길게 수행되는 프로세스 때문에 **준비큐에서 오래 기다리는 현상(호위 효과, convoy effect)** 발생하는 단점이 있음.

<br/>

> ### **SJF(Shortest Job First)**

<span style="color: red"> ###**기준: CPU Burst Time(CPU를 사용하는 시간)**</span> ###

**실행시간이 가장 짧은** 프로세스를 가장 먼저 실행하는 알고리즘

평균 대기시간이 가장 짧은 알고리즘

<br/>

**긴 시간을 가진 프로세스가 실행되지 않는 현상**이 일어날 수 있는 단점이 있음

<br/>

> ### **우선순위**

<span style="color: red"> ###**기준: 우선순위**</span> ###

준비 큐에 들어있는 프로세스들 중 **가장 높은 우선순위를 가진 프로세스에게 CPU를 할당**하되,**우선순위가 같을 경우 선입 선처리(FCFS) 순서로 스케줄된다.**

SJF에서 일어났던 단점 문제를 해결 가능

<br/>

<br/>

- ### 선점형 방식

> ### **라운드 로빈**(RR, Round Robin)

각 프로세스에 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘

**모든 프로세스가 CPU를 할당의 기회를 공정하게 얻기 때문에 기아상태는 발생하지는 않는다.**

<br/>

**타임 퀀텀의 크기**에 성능이 큰 영향을 받는다는 단점이 있음

타임 퀀텀의 크기가 너무 크다면 FIFO 스케줄링과 동일하게 될 것이며, 너무 작다면 문맥 교환이 너무 많이 일어나 프로세스의 실행이 느려짐

<br/>

> ### **SRF(Shortest Remaining Time First)**

**SJF**는 중간에 실행 시간이 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음 짧은 작업을 이어나가는데,

**SRF**는 중간에 **더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행**하는 알고리즘

<br/>

> ### **다단계 큐 스케줄링 (Multilevel Queue Scheduling)**

**우선순위마다의 별도의 준비 큐를 형성**하여 스케줄링하는 방법이다.

 <br/>

프로세스들은 프로세스의 특성(대화형, 배치(background) 등)에 따라 **우선순위가 부여되어 한 개의 큐에 영구적으로 할당되는데**

각 큐에는 그의 성격에 맞는 스케줄링 알고리즘을 별도로 적용할 수 있다. (FCFS, RR 등)

 <br/>

**항상 가장 높은 우선순위 큐의 프로세스에게 CPU를 먼저 할당해준다.**

![img](https://blog.kakaocdn.net/dn/zuBEh/btrHEXUhdd0/xH12cFistakowQehoHVLdK/img.png)

한 프로세스가 실행하고 있던 도중에 인터럽트가 발생, 비자발적으로 문맥 교환이 일어나 준비 큐로 돌아왔다고 가정시

 <br/>

인터럽트를 처리한 후 다시 스케줄링을 하려고 할 때

**기존 수행 중이었던 프로세스가 있는 큐보다 높은 단계의 큐에 새로운 프로세스가 하나라도 있다면**

**바로 그 프로세스에 CPU를 할당해주어야 한다.**

<br/>

## 참고 자료

https://velog.io/@auddwd19/CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC

https://www.crocus.co.kr/1373

https://eunajung01.tistory.com/63

[면접을 위한 CS 전공지식 노트](https://product.kyobobook.co.kr/detail/S000001834833)
