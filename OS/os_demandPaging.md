# 요구 페이징(가상메모리)

- 일반적으로 사용하는 컴퓨터의 메모리는 크기가 한정 되어 있다.
운영체제는 한정된 메모리 공간을 효율적으로 사용하기 위해 가상메모리 기법을 사용한다.

- 가상메모리 기법은 크게 요구 페이징(demand paging)방식과 요구 세그먼테이션(demand segmentation)방식으로 나뉘는데, 대부분의 경우 요구 페이징 기법을 사용한다.

<br>

## 요구 페이징이란?

- 요구 페이징은 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 `당장 사용될 페이지`만을 올리는 방식이다. 

- 따라서 요구 페이징 기법에서는 특정 페이지에 대해 CPU의 요청이 들어온 뒤 해당 페이지를 메모리에 적재한다.

- Pure Demanding page 혹은 Pre-paging 등의 방식으로 사용 가능하다.

**장점**
1. 필요한 페이지만 메모리에 적재하기 때문에 메모리 사용량이 감소한다..
2. 사용되지 않는 주소 영역에 대한 입출력이 줄어 응답시간이 줄어든다.
3. 시스템이 더 많은 프로세스를 수용할 수 있게 해준다.
4. 물리적 메모리의 제약을 벗어날 수 있다.

**단점**
1. 페이지가 실제로 사용될 때 페이지 부재가 발생할 수 있으며, 빈번히 일어날 경우 오버헤드가 발생할 수 있다.
2. 페이지가 초기 할당될 때 0으로 초기화 되어야 하는데, 이 떄 미세한 오버헤드가 발생할 수 있다.

<br>

## 페이지 부재(page fault)

- 프로세스가 실행되는 도중에 필요한 페이지가 물리 메모리에 존재하지 않아 디스크에서 해당 페이지를 가져와야 하는 경우를 말한다. 

- 페이지 부재의 발생 빈도는 페이지 교체 알고리즘과 메모리의 크기 그리고 프로세서의 특성 등에 따라 달라진다.

- 페이지 부재의 발생은 시스템 성능 저하와 이어짐으로, 페이지 교체 알고리즘을 최적화하여 페이지 부재를 최소화하는 것이 중요하다.

- 대표적인 페이지 교체 알고리즘으로는 LRU(Least Recently Used)알고리즘이 있다.

<br>

### LRU(Least Recently Used) 페이지 교체 알고리즘
 - 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다.

 - 최근에 사용된 페이지는 놔두고 오래 전에 사용된 페이지를 대상 페이지로 선정한다. 

 - 알고리즘은 시간을 기준으로 구현할 수 있으며 카운터나 참조 비트를 이용하는 방법도 있다.
<br>

# References
[https://velog.io/@sjlim32/%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95Demandpaging](https://velog.io/@sjlim32/%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95Demandpaging)

[https://chaerim1001.tistory.com/64](https://chaerim1001.tistory.com/64)
